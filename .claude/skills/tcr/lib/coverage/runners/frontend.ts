import type { CoverageResult, CoverageMetrics } from "../types";
import { createEmptyMetrics, meetsThresholds } from "../types";
import { COVERAGE_CONFIG } from "../config";

// ============================================================================
// Vitest Coverage JSON Parser
// ============================================================================

/**
 * Vitest coverage-summary.json structure (json-summary reporter).
 * This provides complete metrics including raw counts, unlike table output.
 */
interface VitestCoverageSummary {
  total: {
    lines: { total: number; covered: number; pct: number };
    statements: { total: number; covered: number; pct: number };
    functions: { total: number; covered: number; pct: number };
    branches: { total: number; covered: number; pct: number };
  };
}

/**
 * Parse Vitest's JSON coverage summary to extract metrics.
 * Reads from coverage/coverage-summary.json generated by the json-summary reporter.
 *
 * Returns null if parsing fails, allowing callers to handle appropriately.
 */
async function parseVitestCoverageJson(
  projectRoot: string
): Promise<CoverageMetrics | null> {
  const summaryPath = `${projectRoot}/coverage/coverage-summary.json`;

  try {
    const file = Bun.file(summaryPath);
    if (!(await file.exists())) {
      console.warn("TCR: Coverage summary file not found:", summaryPath);
      return null;
    }

    const data: VitestCoverageSummary = await file.json();

    if (!data.total) {
      console.warn("TCR: Coverage summary missing 'total' field");
      return null;
    }

    return {
      lines: {
        covered: data.total.lines.covered,
        total: data.total.lines.total,
        percentage: data.total.lines.pct / 100, // Convert from 0-100 to 0-1
      },
      functions: {
        covered: data.total.functions.covered,
        total: data.total.functions.total,
        percentage: data.total.functions.pct / 100,
      },
    };
  } catch (error) {
    console.warn(
      "TCR: Error parsing coverage JSON:",
      error instanceof Error ? error.message : "Unknown error"
    );
    return null;
  }
}

// ============================================================================
// Frontend Coverage Runner
// ============================================================================

export async function runFrontendCoverage(
  testFiles: string[],
  projectRoot: string
): Promise<CoverageResult> {
  const { $ } = await import("bun");
  const config = COVERAGE_CONFIG.frontend;

  // If no test files, return skip with passing status
  if (testFiles.length === 0) {
    return {
      target: "frontend",
      passed: true,
      metrics: {
        lines: { covered: 0, total: 0, percentage: 1 },
        functions: { covered: 0, total: 0, percentage: 1 },
      },
      thresholds: config.thresholds,
      raw: "No frontend test files to run",
    };
  }

  try {
    // Run vitest with coverage
    // vitest.config.ts enforces thresholds, so exit code indicates pass/fail
    // json-summary reporter outputs coverage/coverage-summary.json for parsing
    const result = await $`bun run test:coverage -- ${testFiles}`
      .cwd(projectRoot)
      .quiet()
      .nothrow();

    const stdout = result.stdout.toString();
    const stderr = result.stderr.toString();
    const output = stdout + stderr;

    // Parse coverage metrics from JSON file (generated by json-summary reporter)
    const metrics = await parseVitestCoverageJson(projectRoot);

    // Vitest enforces thresholds via vitest.config.ts, exit code 0 = pass
    const passed = result.exitCode === 0;

    // Determine error message
    let error: string | undefined;
    if (!passed) {
      error = "Tests failed or coverage below threshold";
    } else if (!metrics) {
      error = "Failed to parse coverage JSON - ensure json-summary reporter is configured";
    }

    return {
      target: "frontend",
      passed,
      metrics: metrics ?? createEmptyMetrics(),
      thresholds: config.thresholds,
      raw: output,
      error,
    };
  } catch (error) {
    return {
      target: "frontend",
      passed: false,
      metrics: createEmptyMetrics(),
      thresholds: config.thresholds,
      error:
        error instanceof Error
          ? error.message
          : "Unknown error running frontend coverage",
    };
  }
}

/**
 * Run frontend coverage check for all tests (not specific files).
 * Used by the coverage command and status display.
 */
export async function runFrontendCoverageAll(
  projectRoot: string
): Promise<CoverageResult> {
  const { $ } = await import("bun");
  const config = COVERAGE_CONFIG.frontend;

  try {
    const result = await $`bun run test:coverage`
      .cwd(projectRoot)
      .quiet()
      .nothrow();

    const stdout = result.stdout.toString();
    const stderr = result.stderr.toString();
    const output = stdout + stderr;

    // Parse coverage metrics from JSON file (generated by json-summary reporter)
    const metrics = await parseVitestCoverageJson(projectRoot);
    const passed = result.exitCode === 0;

    // Determine error message
    let parseError: string | undefined;
    if (!passed) {
      parseError = "Tests failed or coverage below threshold";
    } else if (!metrics) {
      parseError =
        "Failed to parse coverage JSON - ensure json-summary reporter is configured";
    }

    return {
      target: "frontend",
      passed,
      metrics: metrics ?? createEmptyMetrics(),
      thresholds: config.thresholds,
      raw: output,
      error: parseError,
    };
  } catch (error) {
    return {
      target: "frontend",
      passed: false,
      metrics: createEmptyMetrics(),
      thresholds: config.thresholds,
      error:
        error instanceof Error
          ? error.message
          : "Unknown error running frontend coverage",
    };
  }
}
